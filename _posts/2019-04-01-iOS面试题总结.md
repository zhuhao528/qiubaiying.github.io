---
layout:     post
title:      iOS面试题总结
subtitle:	  只总结一些细节问题，有些问题需要一篇或者多篇的博文去介绍
date:       2019-04-01
author:     Neil
header-img: img/post-bg-coffee.jpeg
catalog: 	 true
tags:
    - 面试题问题
---

1 IOS开发中ARC下的assign和weak区别

大致的意思是说， weak 比 assign 多了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值为 nil ，这样再向 weak 修饰的属性发送消息就不会导致野指针操作crash。

2 iOS 声明属性时，到底用 strong 还是用 copy，二者有何区别？

当我们声明属性时，如果不希望它因为源对象(源对象为可变对象时)的改变而改变，则用copy修饰。  
详细可参考[iOS 声明属性时，到底用 strong 还是用 copy，二者有何区别？](https://juejin.im/entry/58b4de95570c350058a9b4f6)

3 iOS内存管理问题

MRC 引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。

ARC 背后的原理是依赖编译器的静态分析能力，通过在编译时找出合理的插入引用计数管理代码，从而彻底解放程序员。

- 什么情况下引用计数加一，上面时候减一  
	alloc,copy,retain等会增加引用计数。  
	release 引用计数减一

- autorelease的对象何时释放  
	autoreleased 对象是被添加到了当前最近的 	autoreleasepool 中了，只有当这个 	autoreleasepool 自身 drain 的时候，	autoreleasepool 中的 autoreleased 	对象才会被 release。	
	
- AutoReleasePool原理解析   
	自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的。  
	当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中。  
	调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息。

	
- ARC内存泄漏问题  
	循环引用（Reference Cycle）问题

4 Runtime相关问题  
详细可参考[iOS Runtime详解](https://juejin.im/post/5ac0a6116fb9a028de44d717)

5 RunLoop相关问题  
详细可参考[iOS RunLoop详解]()

6 Blocks相关问题  
详细可参考[《Objective-C 高级编程》](https://juejin.im/post/58f40c0a8d6d810064879aaf)


7 GCD相关问题  

- dispatch_once的作用
	dispatch_once用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执	行block，等block执行完再唤醒所有等待中的线程。
- GCD队列的本质  
	也是FIFO队列，即先进先出


参考  
[《Objective-C 高级编程》](https://juejin.im/post/58fd55c08d6d81005898df46)  
[掘金](https://juejin.im/post/5a90de68f265da4e9b592b40)


8 iOS常用的锁  
常用的锁性能由高到低  
OSSpinLock 不再安全，会有一个优先级反转的问题

```
bool lock = false; // 一开始没有锁上，任何线程都可以申请锁  
do {  
    while(test_and_set(&lock); // test_and_set 是一个原子操作
        Critical section  // 临界区
    lock = false; // 相当于释放锁，这样别的线程可以进入临界区
        Reminder section // 不需要锁保护的代码        
}  
```
自旋锁 如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。

```
int sem_wait (sem_t *sem) {  
  int *futex = (int *) sem;
  if (atomic_decrement_if_positive (futex) > 0)
    return 0;
  int err = lll_futex_wait (futex, 0);
    return -1;
)
```
dispatch_semaphore  信号量 lll_futex_wait这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片  
pthread_mutex 互斥锁 互斥锁的实现原理与信号量非常相似 但是支持多种类型，支持递归锁 所以效率没有信号量高 

```
#define    MLOCK \
- (void) lock\
{\
  int err = pthread_mutex_lock(&_mutex);\
  // 错误处理 ……
}
```
NSLock		NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK, 比 pthread_mutex 略慢的原因在于它需要经过方法调用,但是NSLock有方法缓存  
NSCondition  NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的 因为仅仅条件变量线程不安全 需要与互斥锁配合使用来保证线程安全  使用 condition 有一个好处，我们可以调用 pthread_cond_broadcast 方法通知所有等待中的消费者，这是使用信号量无法实现的。  
NSRecursiveLock 递归锁  NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE  

```
- (void) lockWhenCondition: (NSInteger)value {
    [_condition lock];
    while (value != _condition_value) {
        [_condition wait];
    }
}

- (void) unlockWithCondition: (NSInteger)value {
    _condition_value = value;
    [_condition broadcast];
    [_condition unlock];
}
```
NSConditionLock NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。  
@synchronized 这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。  
可参考[深入理解 iOS 开发中的锁](https://bestswifter.com/ios-lock/)
 
9 你发送的消息不在主线程，接受消息就会自动在子线程中执行（不管你在主线程或者是子线程中注册消息）需要在主线程中执行，怎么办  
可以从定向到主线程执行

10 消息相应链  
事件的传递  
UIApplication->window->寻找处理事件最合适的view  
两个重要的方法:   
hitTest:withEvent:方法  
pointInside方法  
技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！    
事件的响应    
如果当前这个view是控制器的view,那么控制器就是上一个响应者  
如果当前这个view不是控制器的view,那么父控件就是上一个响应者  
[史上最详细的iOS之事件的传递和响应机制-原理篇](https://www.jianshu.com/p/2e074db792ba) 

11 iOS 21种设计模式  
详细可参考[iOS 中的 21 种设计模式](https://www.jianshu.com/p/6b302c7fe987)

12 AFNetWork SDWebImage开源项目

13 tableview的优化 

14 项目开发过程中遇到的问题以及如何解决的

15 哈希表的实现原理？如何解决冲突？  
拉链法  
可参考[解决Hash碰撞冲突方法总结](https://blog.csdn.net/u012104435/article/details/47951357)

16 socket相关问题
socket 通信流程  
第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认  
第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态  
第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

17 HTTP协议

18 算法可参考  
[链表](	http://zhuhao.co/2019/03/28/链表/)  
[二叉树](http://zhuhao.co/2019/03/28/二叉树/)  
[数组](http://zhuhao.co/2019/03/28/数组/)  
[字符串](http://zhuhao.co/2019/03/28/字符串/)  
[递归](http://zhuhao.co/2019/03/28/递归/)

19 iOS架构  
[浅析iOS架构](http://zhuhao.co/2019/03/28/iOS架构/)  

总而言之：面试并不是考你知道什么，而更重要的是你面对问题分析问题解决问题的思路和方法（所以遇到问题时候要沉着心态去思考），好的面试官也是如此，主要考一个人推理能力，能够积极的引导面试者。从这方面说，其实很多面试官是不合格的。还有一个就是尽量诚实，不要撒谎或者隐瞒，如果你不能圆慌，否则很可能丢分。

